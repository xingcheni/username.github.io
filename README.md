# demo1.github.io
个人博客


jdk和jre
	jdk是开发工具，jre是运行环境。
	jdk包含了jre、源码。开发人员必须安装jdk。如果没有jdk的话源码和线程什么都会没有
JRE包含了java虚拟机和java类库。有了jre代码才能正常运行。
什么是字符串常量池
每当创建字符串常量的时候，jvm会先检查常量池，通俗的说常量池里边有的话就不往里放用的时候会直接调用，没有的话会往常量池里放入这个字符串常量


jvm的数据模型

	堆、栈、方法区、本地方法栈、程序计数器
堆是最大的内存空间，New出来的对象、数组就是放在堆中。堆和栈都会抛出异常，如果一个堆里放满了，就会有一个内存溢出异常，俗称OOM。
方法区里边存的是一些被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码，存放在里面。还有动态参数，动态参数是参数个数、类型定义的时候是固定的，可以根据需要在执行的时候传入。
堆和方法区是可以线程共享的。

栈、本地方法栈和程序计数器是私有的
栈是什么，每个方法运行的时候都会创建一个栈针，栈针里边包含了这个方法的变量。
本地方法栈里存的东西和栈一样只不过是c语言写的东西，c语言是唯一一个能调动硬件的语言，为了解决它，java的线程相关的代码就是c语言调用cpu
程序计数器是用来存放执行指令的，就是说为了保证程序能够一直运行下去，cup必须靠着一些手段来保证下一条执行指令的地址，程序计数器就是起到这个作用，for循环、线程、异常、跳出都会用到它

垃圾回收器
	就是会检查堆中所有对象是否会被这些根集对象所引用，不能够被引用的对象就会被垃圾回收器回收。
基础算法有：
	标记-清除
标记需要清除的数据、对象，清除是清除那些标记的对象。这是cms的算法，有个缺点吧清除后会产生碎片。如果在刚刚清除完的时候又产生了垃圾，这是浮动垃圾
	标记-整理
通俗的说就是为了解决浮动垃圾又增加了一次扫描清除，然后清除过后产生的碎片也会被他整理好
	复制
它会把内存空间分为两个相等的区域，每次使用只用一个区域。进行垃圾回收会遍历使用的区域，把正在使用的对象复制到另一个区域，并且复制过去后会整理，不会有碎片。缺点是需要两倍的空间
	分代收集算法
不同对象的生命周期是不一样的，所以可以采取不同的收集方式，就是分为新生代和老年代还有持久代，持久代里存放的是类信息，跟回收关系不大就不说了。

	什么是新生代和老年 代呢？
新生代就是刚创建的对象，比如所student1 = new student()，那这个就是放在新生代的。老年代里就是比较活跃的对象，也就是说经常被引用的。

	为什么会分为新生代和老年代？
就是每个对象的生命周期不同，为了更方便的来管理和提高效率，新生代管理刚创建的，老年代管理被频繁使用的

	新生代如何晋升为老年代？
比如说这是一个堆内存图，分为四块sden区域（新生代），from，to（为了做一个复制算法），和老年代。打比方说Student1 = new student()这是个新创建的对象，刚创建完就是放在新生代里，如果垃圾回收的时候遍历发现它正在使用，就给把他放在from，to复制算法里，相当于它是有用的不会回收。这个垃圾回收机制一般在新生代里比较多，也不是说进入老年代就不会被回收，老年代一般是标记-压缩。总的来说新创建的在新生代，如果遍历扫描发现它有用的话有用就会进入from、to区域，如果在from、to区域被频繁使用的话 就会进入老年代，这个频繁使用大概的话是15次左右。

	类同时满足三个条件才算是无用的类
1.这个类所有的实例都已经被回收
2.这个类对应的java.lang.class对象没有在任何的地方被引用
3.加载这个类的ClassLoader已经被回收

	Java类的加载机制
这个加载机制就是JVM把.class文件加载到内存，并对数据进行加载、验证、准备、解析、初始化然后形成可以使用的Java类的机制。
加载：查找并加载这个类

验证：验证java里的语法是否规范，比如说这个类不能以下划线开头、$开头和数字开头

准备：为类的静态变量分配内存并设置它初始值，就是定义一个int类型等于3，他会先定义为默认值0，在初始化的阶段才把这个3复制给它

解析：主要是把常量池中的符号引用替换成直接引用
主要是针对类或者接口、接口方法、类方法、方法类型、字段等等七个符号引用进行的。符号引用就是一组符号来描述目标，它可以使任何字面量。直接引用就是直接指向目标的指针。

初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。为类变量进行初始化有两种：
1.声明类变量是指定初始值
2.使用静态代码块为类变量指定初始值

什么是class文件
为Java程序提供独立于底层主机平台的二进制形式的服务。

双亲委派
双亲委派是是指一个类加载器收到一个类加载请求的时候，该类加载器首先会把请求委派给父类加载器，只有父类加载器在自己的搜索范围找不到指定类时候，子类加载器才会尝试自己去加载。那么什么是类加载器，类加载器是jre的一部分，负责动态的将类加载到虚拟机。

类加载器分类
启动类加载器 bootstrap class 111loader ：加载jre/lib/rt.java，主要加载核心的类库
扩展类加载器 extension classloader  : 加载jre/lib/*.java，主要加载jre/lib/ext目录下的一些扩展的jar
应用程序类加载器 application classloader ：加载classpath上指定的类库，主要负责加载应用程序的主函数类


类库
就是一个面向对象的可重用的类型集合，这些类型包括接口、抽象类、具体类。


Java为什么要用双亲委派模式，他有什么好处？
假如类java.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因为Object类在各种类加载器环境中都是同一个类，相反的是，如果自己定义一个java.lang.Object类，并且放在classpath中，那系统就会出现多个不同的Object类，程序就会一片混乱。
双亲委派的好处是：防止重复加载同一个.class，保证了数据安全
保证核心.class不能被篡改，即使篡改也不会加载，就算加载了也不是同一个对象。不同的加载器加载同一个.class也不是同一个.class对象。保证了class的执行安全


rt.jar：Java基础类库，也就是Java doc里面看到的所有的类的class文件。
tools.jar：是系统用来编译一个类的时候用到的，即执行javac的时候用到。
dt.jar：dt.jar是关于运行环境的类库，主要是swing包

双亲委派的执行流程
当Application ClassLoader（应用程序类加载器）收到一个类加载请求时，他首先不会自己去加载这个类，而是把这个请求委派为父类加载器Extension ClassLoader（扩展类加载器）去完成。
当Extension ClassLoader（扩展类加载器）收到一个类加载请求时，他也不会自己去加载这个类，也是把这个请求委派给父类加载器Bootstrap ClassLoader（启动类加载器）去完成。
如果Bootstrap ClassLoder（启动类加载器）加载失败，就会让Extension Classloader（扩展类加载器）去加载。
如果Extension Classloader（扩展类加载器）加载失败，就会找Application ClassLoader（应用程序类加载器去加载）。
如果说都加载失败的话，就会抛出一个ClassNotFoundException异常
